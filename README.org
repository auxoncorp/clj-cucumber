* auxon.clj-cucumber
A more idiomatic and up-to-date binding of JVM cucumber to Clojure. No global
state, and suitable for repl-based development. Also lets you write proptests
with Gherkin syntax.

** Usage
*** Add the dependency
Add it to your deps.edn

#+begin_src clojure
  {:deps {auxon/clj-cucumber {:git/url "https://github.com/auxon/clj-cucumber"
                              :sha "<>"}}}
#+end_src

*** Make a feature file
Make a feature file, and put it somewhere in your source tree. =test/features=
is a handy location.

#+begin_src feature
  Feature: A passing feature
    Scenario: Successful test
      Given some setup
      When I do a thing
      Then the setup happened
      And the thing happened
#+end_src
*** Make a test file
Make a regular clojure test, and call =run-cucumber= from it. 

#+begin_src clojure
  (ns cucumber-test
    (:require [clojure.test :refer :all]
              [auxon.clj-cucumber :refer [run-cucumber step]]))

  (def test-state (atom {}))

  (def steps
    [])

  (deftest cucumber
    (is (= 0 (run-cucumber "test/features/passing.feature" steps))))
#+end_src

*** Run the tests and copy the template step defs
Run your test in whatever way you do normally, then see what was printed. Copy
the step templates into your list of steps.

#+begin_src sh :results verbatim
  clj -A:test:runner
#+end_src

#+begin_example
<snip>

You can implement missing steps with the snippets below:

(step :Given #"^some setup$"
      (fn some-setup [state]
        (comment  Write code here that turns the phrase above into concrete actions)
        (throw (cucumber.api.PendingException.))))

(step :When #"^I do a thing$"
      (fn I-do-a-thing [state]
        (comment  Write code here that turns the phrase above into concrete actions)
        (throw (cucumber.api.PendingException.))))

(step :Then #"^the setup happened$"
      (fn the-setup-happened [state]
        (comment  Write code here that turns the phrase above into concrete actions)
        (throw (cucumber.api.PendingException.))))

(step :Then #"^the thing happened$"
      (fn the-thing-happened [state]
        (comment  Write code here that turns the phrase above into concrete actions)
        (throw (cucumber.api.PendingException.))))
#+end_example

*** Fill in the blank
Fill out the body as appropriate.

#+begin_src clojure
  (def steps
    [(step :Given #"^some setup$"
           (fn some-setup [_]
             {:setup-happened true}))

     (step :When #"^I do a thing$"
           (fn I-do-a-thing [state]
             (assoc state :thing-happened true)))

     (step :Then #"^the setup happened$"
           (fn the-setup-happened [state]
             (assert (:setup-happened state))))

     (step :Then #"^the thing happened$"
           (fn the-thing-happened [state]
             (assert (:thing-happened state))))])
#+end_src

*NB* You should use =assert= in your step defs rather than clojure.test's =
macro, so the cucumber test runner can observe the assertion failures.

*** Happily run your now-passing tests
#+begin_src sh :results verbatim
  clj -A:test:runner
#+end_src

#+begin_example

Running tests in #{"test"}

Testing cucumber-test
Feature: A passing feature

  Scenario: Successful test # test/features/my.feature:2
    Given some setup        # cucumber_test.clj:8
    When I do a thing       # cucumber_test.clj:13
    Then the setup happened # cucumber_test.clj:17
    And the thing happened  # cucumber_test.clj:21

1 Scenarios (1 passed)
4 Steps (4 passed)
0m0.019s


Ran 1 tests containing 1 assertions.
0 failures, 0 errors.
#+end_example
** Steps
Steps are maps. The =step= macro is provided to seamlessly populate the line
number information in them, which the cucumber library uses when printing
results.

The first parameter to each step function is a state variable. This is passed
between steps; the value returned by =:Given= and =:When= functions is used as
the state value for subsequent steps. =:Then= functions cannot modify the state,
so they don't need to return anything.

** Hooks
You can add hooks, too, alongside your steps. Use the =hook= macro to make them.
#+begin_src clojure
  (def steps
    ;; these happen before and after the scenario
    [(hook :before (fn before-hook [state] ...))
     (hook :after (fn after-hook [state] ...))
     ;; these happen before and after each step
     (hook :before-step (fn before-step-hook [state] ...))
     (hook :after-step (fn after-step-hook [state] ...))

     (step :Given ...)])
#+end_src

As with steps, all hook functions are passed the state, and their return value
is used as the new state.

** Generative tests
You can write generative (property-based) tests with your gherkin specs! This is
effectively a special mode; the `auxon.clj-cucumber.generative` namespace
defines a =before-hook= and =after-hook= that use the environment to accumulate
generators and properties as the feature executes, then check them at the end.

See [[file:test/auxon/clj_cucumber/generative_test.clj]] and
[[file:test/auxon/clj_cucumber/features/generative.feature]] for an example of how
to do this.

** Testing
#+begin_src sh
  clj -A:test:runner
#+end_src
** License
Copyright Â© 2019 Russell Mull

Distributed under the Eclipse Public License either version 1.0 or (at
your option) any later version.
